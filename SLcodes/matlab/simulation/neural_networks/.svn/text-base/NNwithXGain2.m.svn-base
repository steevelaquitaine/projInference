%NNwithXGain2.m

% author: steeve laquitaine
%   date: 140424 last modification 140602
%  
%  usage: 
%       dirTrained=repmat(1:1:360,1,1);
%       whichNeurInaVoxMT=[];
%       whichNeurInaVoxPost=[];
%       whichNeurInaVoxPrior=[];
%       [llhBOLDmn,postBOLDmn,priorBold]=NNwithXGain2(dirTrained,...
%           'priorstd=0',...
%           'priormean=225',...
%           'numVoxsMT=1',...
%           'numVoxsPost=100',...
%           'NeurInaVoxMT=1',...
%           'NeurInaVoxPost=1000',...
%           whichNeurInaVoxMT,...
%           whichNeurInaVoxPost,...
%           whichNeurInaVoxPrior,...
%           15,...
%           'sortVoxels=on',...
%           'displayNetwork=on',...
%           'displayBOLD=off');
% 
% purpose: Simulation of neural and BOLD responses of a Bayesian network of
%          llh, prior and posterior areas
% 
% Description:
%         Hardware
%         - 16 llh neurons with equally spaced direction preferences
%         - 45 degrees for a full width at half height of 106 degrees (Albright, 1984)
%         For a Von Mises, it is a concentration parameter k of 2.34.
%         - Encoding neurons are assumed statistically independent (Jazayeri, 2006)
%         - Prior's concentration is k=0.1;
%         - We assume same number of neurons and llh. Each neuron from llh
%         projects to only one neuron in Post.
%         - decoding: 360 Post neurons have 1 readout direction each.
%         note: in Jazayeri, readout rule have cosine profiles..
% 
%         360 000 neurons in each voxel
%         https://cfn.upenn.edu/aguirre/wiki/public:neurons_in_a_voxel
% 
% Operations
%         - The tuning curves fj in the sensory neurons (encoding) stay unchanged.
%         - The logPrior adds to the PreSynaptic inputs; added to (Habenschuss,2013;
%         Jazayeri,2006).
%         - The weight of each encoder-decoder neuron is set according to
%         Habenschuss et al., 2013 (consistent with Jazayeri et al., 2006)
%         W_ed=logf_e(dir_d)+const
%         - Winner-takes-all competition by divisive normalization(Carandini,Heeger)
%         a common inhibitory signal with constant total firing rate in Post
%         (homeostasy).
% 
% Questions
%         - How are llh and Post connected? Are there tuning curves in Post?
%         How does Post represent posterior (decision variable), like llh?
%         - Is prior gain represented in a probabilistic population of neurons with
%         tuning curves (Ma et al., 2006)? See Simoncelli, 2009. No directly in the
%         encoder-decoder synaptic weight after learning.

function [llhBOLDmn,PostBOLDmn,PriorBOLDmn,k,VoxRespAmpPrior,VoxPrefDirllh,VoxPrefDirPost,whichNeurInaVoxllh,whichNeurInaVoxPost,whichNeurInaVoxPrior]=NNwithXGain2(motionDir,...
    priorstd,...
    priormean,...
    numVoxsllh,...
    numVoxsPost,...
    NeurInaVoxllh,...
    NeurInaVoxPost,...
    whichNeurInaVoxllh,...
    whichNeurInaVoxPost,...
    whichNeurInaVoxPrior,...
    numNeurllhkj,...
    sortVoxels,...
    OptiondisplayNetwork,...
    OptiondisplayBOLD)

%Post readout neurons and total output firing assuming Homeostasy.
k=1:1:360;
numNeurPostk=numel(k);
rtotal=10000;

%prior
PriorMean=str2double(priormean(find(priormean=='=')+1:end));
priorstd=str2double(priorstd(find(priorstd=='=')+1:end));
PriorGain=vmPdfs(k,PriorMean,priorstd,'norm');

%HARDWARE and FIRING
numVoxsllh=str2double(numVoxsllh(find(numVoxsllh=='=')+1:end));
numVoxsPost=str2double(numVoxsPost(find(numVoxsPost=='=')+1:end));
NeurInaVoxllh=str2double(NeurInaVoxllh(find(NeurInaVoxllh=='=')+1:end));
NeurInaVoxPost=str2double(NeurInaVoxPost(find(NeurInaVoxPost=='=')+1:end));

%llh's encoder (preferred directions must be evenly spaced !!)
DirPref=1:360/numNeurllhkj:360;
if fix(360/numNeurllhkj)-360/numNeurllhkj~=0
    fprintf('%s \n','(NNwithXGain2) Number of llh neurons must be multiple of 360')
    keyboard
end
DirK=2.34;
Fkj=vmPdfs(k,DirPref',DirK(ones(numel(DirPref),1),1),'norm');
rllhj=nan(numel(motionDir),numNeurllhkj);

%VOXELS
%llh's neurons in each voxel whichNeurInaVox (neurons,voxels). You can
%input the neurons yourself e.g., when you want to run different 
%analyses on the same voxels' set.
%e.g., if you sample from a pool of 15 direction-selective neurons, 
%whichNeurInaVoxllh values range between 1:1:15.
%If you dont' input any value the code automatically simulate a set of
%voxels
if isempty(whichNeurInaVoxllh)
    whichNeurInaVoxllh=nan(NeurInaVoxllh,numVoxsllh);
    for j=1:numVoxsllh
        whichNeurInaVoxllh(:,j)=randsample(1:1:numNeurllhkj,NeurInaVoxllh,true);
    end
else
    fprintf('%s \n','(NNwithXGain2) Neurons have been assigned to their llh voxels..done')
end

%Post's neurons in each voxel whichNeurInaVoxPost (neurons,voxels). You can 
%input the neurons yourself.You can input the neurons yourself e.g., when 
%you want to run different analyses on the same voxels' set.
%e.g., if you sample from a pool of 360 readout neurons,whichNeurInaVoxllh 
%values range between 1:1:360.
%If you dont' input any value the code automatically simulate a set of
%voxels
if isempty(whichNeurInaVoxPost)
    whichNeurInaVoxPost=nan(NeurInaVoxPost,numVoxsPost);
    for j=1:numVoxsPost
        whichNeurInaVoxPost(:,j)=randsample(1:1:numNeurPostk,NeurInaVoxPost,true);
    end
else
    fprintf('%s \n','(NNwithXGain2) Neurons have been assigned to their posterior voxels...done')
end
llhBOLDmn=nan(numVoxsllh,numel(motionDir));
PostBOLDmn=nan(numVoxsPost,numel(motionDir));

%Voxels' BOLD in Prior area
numVoxsPrior=100;
numNeurPriork=numel(k);
NeurInaVoxPrior=1000;
if isempty(whichNeurInaVoxPrior)
    whichNeurInaVoxPrior=nan(NeurInaVoxPrior,numVoxsPrior);
    for j=1:numVoxsPrior
        whichNeurInaVoxPrior(:,j)=randsample(1:1:numNeurPriork,NeurInaVoxPrior,true);
    end
else
    fprintf('%s \n','(NNwithXGain2) Neurons have been assigned to their prior voxels...done')
end
PriorBOLDmn=nan(numVoxsPrior,numel(motionDir));


%Simulate firing and BOLD for different motion directions trials
fprintf('%s \n','(NNwithXGain2) Now running the Bayesian network...if "displayBOLD==on" wait for plot')
screen=get(0,'ScreenSize');

%Graphics
C=linspecer(numNeurllhkj);

%progress indicator
%h=waitbar(0,'Please wait...');
for i=1:numel(motionDir);
    
    %progress indicator
    %perc=fix((i/numel(motionDir))*100)/100;
    %waitbar(perc,h,sprintf('%d%% diplaying motions directions',perc*100))
    
    %print progress
    SLprintProgress(i,numel(motionDir))
    
    %llh neurons firing
    dirThisTrial=k==motionDir(i);
    rllhj(i,:)=Fkj(dirThisTrial,:);
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        figure(1)
        set(gcf,'position',...
            [0*screen([3 4]) 0.4*screen(3) screen(4)],...
            'color','w')
        clf
        subplot(531);
        set(gca,'NextPlot','replacechildren', 'ColorOrder',C);
        hold all
        plot(Fkj,'linesmoothing','on','linewidth',3)
        
        %indicate currently displayed motion direction
        motionspace=1:1:360;
        pos=motionspace(k==motionDir(i));
        
        %indicate each neuron's activity at this direction
        plot(pos(ones(1,numNeurllhkj)),rllhj(i,:),'.','markersize',20)
        xlim([0 360])
        xlabel('Motion direction (degrees)','fontsize',14)
        ylabel('Firing rate (sp/sec)','fontsize',14)
        title('llh direction-tuned neurons','fontsize',14,'fontweight','bold')
        box off
    end
    
    %Prior with multiplicative gain
    %Need to think about how to relate Prior's std to the multiplicative gain
    %but for now multiplicative gain's std is prior's std.
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        subplot(539);
        plot(log(PriorGain),'color',[1 0 0],'linesmoothing','on',...
            'linewidth',3)
        xlim([0 360])
        xlabel('Motion direction (degrees)','fontsize',14)
        ylabel('Weight','fontsize',14)
        title({'Prior weight (hypothetical)','logprior(\theta_k)'},...
            'fontsize',14,'fontweight','bold','color','r')
        box off
    end
        
    %Synaptic weights of llh neuron - Post neurons. It is the
    %neurons logLlh weight (Jazayeri et al., 2006). Some terms isolated
    %during posterior derivation are assumed constant over motion directions
    %and have been dropped(see Jazayeri et al., 2006).
    Wkj=log(Fkj);
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        subplot(534)
        set(gca,'NextPlot','replacechildren', 'ColorOrder',C);
        plot(k,Wkj,'linesmoothing','on','linewidth',3)
        xlim([0 360])
        title({'Connections weights','(logf_j)'},...
            'fontsize',14,'fontweight','bold')
        xlabel('Motion direction (degrees)','fontsize',14)
        ylabel('Weight','fontsize',14)
        box off
    end
   
    
    %Pooled synaptic weights (FR, Wkj, prior)
    %Synaptic weights are pooled for each readout neuron.
    %example
    %rllhj(i,:)=Fkj(k==motionDir(i),:);
    rllhjThisTrial=rllhj(i,:);
    rllhkj=rllhjThisTrial(ones(numel(k),1),:);
    pooledWj=sum(rllhkj.*Wkj,2);
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        subplot(537);
        plot(k,pooledWj,'k','linesmoothing','on','linewidth',3)
        xlim([0 360])
        ylim([1.02*min(pooledWj) 0.98*max(pooledWj)])
        title({'Pooled presynaptic inputs','(logllh(\theta_k)=\Sigma_j r_j*logf_j(\theta_k))'},...
            'fontsize',14,'fontweight','bold')
        xlabel({'Readout neurons','by readout direction (degrees)'},...
            'fontsize',14)
        ylabel('Weight','fontsize',14)
        box off
    end
    
    %Post's decoder neurons output firing rate(max pooling)
    %Based on Habenschuss' derivation assuming divisive normalization
    %(inhibition). It is a softmax or attractor network. It makes sure the total
    %firing rate in Post remains constant.
    %- if a readout neuron firing rate is r_k=exp(u_k)
    %- if r_k depends on u_k=sum_j(w_k.*r_j + logprior - I)
    %- if r_total=sum_k(r_k) is maintained
    %- the ideal divisive inhibition is I=log(Sum(exp(w_k.*r_j + logprior))) -
    %logr_total
    %note: pooledWj is w_k.*r_j.
    %r_j is neuron j's firing
    %and
    %in Habenschuss beta=1;
    beta=1;
    rPostk=rtotal.*exp(beta*(pooledWj+log(PriorGain)))./sum(exp(beta*(pooledWj+log(PriorGain))));
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        subplot(5,3,11);
        plot(k,rPostk,'k','linesmoothing','on','linewidth',3)
        xlim([0 360])
        ylim([0.75*min(rPostk) 1.5*max(rPostk)])
        title({'Post neurons responses','logllh(\theta_k)+logprior'},...
            'fontsize',14,'fontweight','bold')
        xlabel({'Readout neurons','by readout direction (degrees)'},...
            'fontsize',14)
        ylabel('Firing rate (sp/sec)','fontsize',14)
        box off
    end
    
    
    %Visualize prior and llh weights at the same scale
    l=log(PriorGain); 
    minY=min([l(:);pooledWj(:)]);
    maxY=max([l(:);pooledWj(:)]);
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        sp=subplot(538);
        hold all
        plot(k,log(PriorGain),'color',[1 0 0],'linesmoothing','on',...
            'linewidth',3)
        plot(k,pooledWj,'color','k','linesmoothing','on','linewidth',3)
        xlim([0 360])
        xlabel('Motion direction (degrees)','fontsize',14)
        ylabel('Weight','fontsize',14)
        title({'logPrior and logllh at same scale'},...
            'fontsize',14,'fontweight','bold','color','k')
        box off
        set(sp,'ylim',[minY-0.1*(maxY-minY) maxY+0.1*(maxY-minY)])
    end

    %read-out the direction
    [~,pos]=max(rPostk);
    estimate=k(pos);
    if strcmp(OptiondisplayNetwork,'displayNetwork=on')==1
        subplot(5,3,14)
        drawVectors(motionDir(i),1)
        hold on
        drawVectors(estimate,1)
        hold on
        drawVectors(PriorMean,1)
        coor=polar2cartesian(estimate,2.1);
        text(coor(1),coor(2),num2str(estimate),'color','r','fontsize',20,...
            'fontweight','bold');
    end   
    
    %Voxels' BOLD in llh and Post
    %llh only produces sensory responses r_j. A voxel is made out of 1000 
    %neurons randomly sampled from the initial pool of 15 llh direction-
    %selective neurons.
    %Post produces responses rPostk. An Post voxel is made out of 1000 readout 
    %neurons randomly sampled from the initial pool of 360 Post neurons
    %selective for one direction only.
    llhBOLD=makeVoxels(whichNeurInaVoxllh,rllhjThisTrial,'verbose=off');    
    PostBOLD=makeVoxels(whichNeurInaVoxPost,rPostk,'verbose=off');
    PriorBOLD=makeVoxels(whichNeurInaVoxPrior,log(PriorGain),'verbose=off');
    llhBOLDmn(:,i)=llhBOLD;
    PostBOLDmn(:,i)=PostBOLD;
    PriorBOLDmn(:,i)=PriorBOLD;
    drawnow
end

%end progress
fprintf('\n');


%VOXELS
VoxPrefDirllh=[];
VoxPrefDirPost=[];
VoxRespAmpPrior=[];
if strcmp(sortVoxels,'sortVoxels=on')==1

    %print
    fprintf('%s',['(NNwithXGain2) Getting voxels direction',...
        ' selectivity and sorting voxels by direction selectivity...'])

    %Calculate average BOLD for each direction and voxels preferred
    %direction for llh and Post. BOLD is averaged over repetition of directions.
    %Preferred direction is the direction that elicits maximum average BOLD.
    %h=waitbar(0,'Please wait...'); Prior voxels have no direction
    %selectivity and fire the same way whatever displayed direction.
    VoxPrefDirllh=nan(numVoxsllh,1);
    %     parfor vox=1:numVoxsllh;
    for vox=1:numVoxsllh;
        
        [m,s]=makeStat(llhBOLDmn(vox,:)',motionDir);
        [~,PrefDirllh]=max(m);
        VoxPrefDirllh(vox)=PrefDirllh;
        
        %progress
        %perc=fix((vox/numVoxsllh)*100)/100;
        %waitbar(perc,h,sprintf('%d%% sorting llh voxels based on direction selectivity',perc*100))
    end
    %close(h)
    
    %progress
    %h=waitbar(0,'Please wait...');
    VoxPrefDirPost=nan(numVoxsPost,1);
    %     parfor vox=1:numVoxsPost;
    for vox=1:numVoxsPost;
        
        [m,s]=makeStat(PostBOLDmn(vox,:)',motionDir);
        [~,PrefDirPost]=max(m);
        VoxPrefDirPost(vox)=PrefDirPost;
        
        %progress
        %perc=fix((vox/numVoxsPost*100))/100;
        %waitbar(perc,h,sprintf('%d%% sorting Post voxels based on direction selectivity',perc*100))
    end
    %close(h)
    
    %sort matrix of BOLD by voxels preferred directions
    [VoxPrefDirllh,Illh]=sort(VoxPrefDirllh);
    llhBOLDmn=llhBOLDmn(Illh,:);
    
    [VoxPrefDirPost,IPost]=sort(VoxPrefDirPost);
    PostBOLDmn=PostBOLDmn(IPost,:);
    
    [VoxRespAmpPrior,IPrior]=sort(PriorBOLDmn(:,1));
    PriorBOLDmn=PriorBOLDmn(IPrior,:);
   
    %stick neurons to their voxels
    whichNeurInaVoxllh=whichNeurInaVoxllh(:,Illh);
    whichNeurInaVoxPost=whichNeurInaVoxPost(:,IPost);
    whichNeurInaVoxPrior=whichNeurInaVoxPrior(:,IPrior);
    fprintf('%s \n','done')
end

%draw llh and Post BOLD.
if strcmp(OptiondisplayBOLD,'displayBOLD=on')==1
    
    %calculate average BOLD response for unique direction
    unqDir=unique(motionDir);
    for i=1:numel(unqDir);
        %llh, posterior and Prior
        meanllhBOLDoverRep(:,i)=mean(llhBOLDmn(:,motionDir==unqDir(i)),2);
        meanPostBOLDoverRep(:,i)=mean(PostBOLDmn(:,motionDir==unqDir(i)),2);
        meanPriorBOLDoverRep(:,i)=mean(PriorBOLDmn(:,motionDir==unqDir(i)),2);
    end
    
    %draw BOLD responses for each voxels for unique directions (each screen
    %refresh)
    figure;
    set(gcf,'position',...
        [0.4*screen(3) 0.9*screen(4) 0.4*[screen(3) screen(4)]],...
        'color','w')
    for i=1:numel(unqDir);
        
        %llh
        subplot(311)
        plot(1:1:numVoxsllh,meanllhBOLDoverRep(:,i),'color',[.5 .5 .5],...
            'linesmooth','on','linewidth',2)
        title({'llh',['BOLD=\Sigma FR of',num2str(NeurInaVoxllh),...
            ' sampled neurons for direction ',num2str(unqDir(i)),' degrees']},...
            'fontsize',14)
        xlabel('Voxels by preferred directions (degrees)','fontsize',14)
        ylabel('Simulated Bold response','fontsize',14)
        xlim([0 numVoxsllh])
        ylim([0.99*min(meanllhBOLDoverRep(:)) 1.01*max(meanllhBOLDoverRep(:))])
        
        if strcmp(sortVoxels,'sortVoxels=on')==1 
            set(gca,'fontsize',14,'xtick',1:10:numVoxsllh,'xticklabel',...
                VoxPrefDirllh(1:10:end))
        end
        box off
        
        %Post
        subplot(312)
        plot(1:1:numVoxsPost,meanPostBOLDoverRep(:,i),'color',[.5 .5 .5],...
            'linesmooth','on','linewidth',2)    
        title({'Post',['BOLD=\Sigma FR of ',num2str(NeurInaVoxPost),... 
            'sampled neurons for direction ',num2str(unqDir(i)),' degrees']},...
            'fontsize',14)
        xlabel('Voxels by preferred directions (degrees)','fontsize',14)
        ylabel('Simulated Bold response','fontsize',14)
        xlim([0 numVoxsPost])
        ylim([0.99*min(meanPostBOLDoverRep(:)) 1.01*max(meanPostBOLDoverRep(:))])
        if strcmp(sortVoxels,'sortVoxels=on')==1
            set(gca,'fontsize',14,'xtick',1:10:numVoxsPost,'xticklabel',...
                VoxPrefDirPost(1:10:end))
        end
        box off
        
        %Prior
        subplot(313)
        plot(1:1:numVoxsPrior,meanPriorBOLDoverRep(:,i),'color',[.5 .5 .5],...
            'linesmooth','on','linewidth',2)   
        title({'Prior',['BOLD=\Sigma FR of ',num2str(NeurInaVoxPrior),...
            'sampled neurons for direction ',num2str(unqDir(i)),' degrees']},...
            'fontsize',14)
        xlabel('Voxels by preferred directions (degrees)','fontsize',14)
        ylabel('Simulated Bold response','fontsize',14)
        xlim([0 numVoxsPrior])
        ylim([1.01*min(meanPriorBOLDoverRep(:)) 0.99*max(meanPriorBOLDoverRep(:))])
        if strcmp(sortVoxels,'sortVoxels=on')==1
            set(gca,'fontsize',14,'xtick',1:10:numVoxsPrior,'xticklabel',...
                VoxRespAmpPrior(1:10:end))
        end
        box off        
        drawnow
    end
end

%Distribution of voxels preferred directions for llh and Post. We expect a
%uniform representation of preferred directions across voxels.
if strcmp(sortVoxels,'sortVoxels=on')==1
    if strcmp(OptiondisplayBOLD,'displayBOLD=on')==1
        
        %print
        fprintf('%s','Calculating distribution of voxels preferred directions...')
        
        %draw
        figure('color','w')
        set(gcf,'position',...
            [0.4*screen(3) 0.05*screen(4) 0.4*[screen(3) screen(4)]],...
            'color','w')
        %llh
        subplot(121)
        hist(VoxPrefDirllh)
        set(get(gca,'child'),'FaceColor',[.7 .7 .7],'EdgeColor',[.7 .7 .7]);
        box off
        title('llh voxels')
        xlabel('Voxels preferred directions (degrees)')
        ylabel('Number of voxels')
        box off

        %posterior
        subplot(122)
        hist(VoxPrefDirPost)
        set(get(gca,'child'),'FaceColor',[.7 .7 .7],'EdgeColor',[.7 .7 .7]);
        title('Post voxels')
        xlabel('Voxels preferred directions (degrees)')
        ylabel('Number of voxels')
        box off
        fprintf('%s \n','done')
    end
end

%the End
fprintf('%s \n','(NNwithXGain2) Bayesian network...done') 

