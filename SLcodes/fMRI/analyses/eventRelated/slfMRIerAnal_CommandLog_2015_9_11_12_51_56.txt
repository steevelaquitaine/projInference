
ans =

/Users/steeve/proj/SLcodes/fMRI/analyses/eventRelated/slfMRIerAnal_mfileLog_2015_9_11_12_51_56.txt

{Error using cd
Cannot CD to /Users/steeve/fMRI_data/s02520140501/ (Name is nonexistent or not a directory).

Error in SLfMRIeventRelatedAnalysis (line 26)
cd /Users/steeve/fMRI_data/s02520140501/
} 
edit SLfMRIeventRelatedAnalysis
v = getMLRView;
(getView) Multiple figures open, returning last one
myROI          = loadROITSeries(v,o.myROIname);
(loadROITSeries) Loading tSeries for rMT from MotionComp: 1 00% (00:00:00)02% (00:01:11)05% (00:00:34)08% (00:00:22)10% (00:00:16)13% (00:00:12)16% (00:00:10)18% (00:00:08)21% (00:00:07)24% (00:00:06)27% (00:00:05)29% (00:00:04)32% (00:00:04)35% (00:00:03)37% (00:00:03)40% (00:00:02)43% (00:00:02)45% (00:00:02)48% (00:00:02)51% (00:00:01)54% (00:00:01)56% (00:00:01)59% (00:00:01)62% (00:00:01)64% (00:00:01)67% (00:00:00)70% (00:00:00)72% (00:00:00)75% (00:00:00)78% (00:00:00)81% (00:00:00)83% (00:00:00)86% (00:00:00)89% (00:00:00)91% (00:00:00)94% (00:00:00)97% (00:00:00)99% (00:00:00)took 1 secs 999 ms
scanDims       = viewGet(v,'scanDims');         
myROI.linearScanCoords = sub2ind(scanDims,myROI.scanCoords(1,:),myROI.scanCoords(2,:),myROI.scanCoords(3,:)); %ROI coord converted to linear
%r2             = viewGet(v,'overlayData',o.myGroupScanNum);    %r2 map that will permit to choose highest r2 voxels
r2             = viewGet(v,'overlayData',1);    %r2 map that will permit to choose highest r2 voxels
myROI.r2       = r2(myROI.linearScanCoords);                   %pick ROI's r2s
tSeries        = mean(myROI.tSeries(myROI.r2>o.myr2Thresh,:)); %average TSeries for high r2 vox
numVoxelsTotal = sum(myROI.r2>0); % # voxels with r2 greater than the threshold
numVoxels      = sum(myROI.r2 > o.myr2Thresh);
stimvol        = getStimvol(v,o.myVar,'taskNum',o.taskNum,'phaseNum',o.phaseNum,'segmentNum',o.segmentNum); %choose the # of HRF to deconvolve (i.e., # of stimuli) from the average TSeries.
(getStimvolFromVarname) taskNum=[2], phaseNum=[1], segmentNum=[2]
(getStimvolFromVarname) _all_: 15 trials
nhdr           = length(stimvol);
hdrlen         = 50; %hdr length

%make a stimulus convolution matrix (scm, Ninstances by Nhdr's time. 
%scm = 1 at the times when we estimate hdr values).
scm            = makescm(v,hdrlen,1,stimvol);

size(scm)

ans =

    56    50

d              = getr2timecourse(tSeries,nhdr,hdrlen,scm,viewGet(v,'framePeriod')); %deconvolve hdrs from mean TSeries


% init some variables
ehdr=[];r2 = [];

if ieNotDefined('verbose'),verbose = 1;end

% precalculate the normal equation (this dramatically speeds up things)
covarianceMatrix = d.scm'*d.scm;
covarianceMatrixRank = rank(covarianceMatrix);
% use normal equations if we have a full ranked covariance matrix
if covarianceMatrixRank == size(covarianceMatrix,1)
  inverseCovarianceMatrix = covarianceMatrix^-1;
  precalcmatrix = inverseCovarianceMatrix*d.scm';
  diagOfInverseCovariance = diag(inverseCovarianceMatrix);
% otherwise use pinv
else
  % note that if we need to use the pseudo inverse it means that there is ambiguity in the design
  % such that there are an infinite number of possible solutions. The psuedo-inverse solution
  % chosses the solution with the minimum length (i.e. Euclidian norm)
  if verbose,disp(sprintf('(getr2) Design covariance matrix (%ix%i) is rank %i. Using pseudo-inverse to invert.',size(covarianceMatrix,1),size(covarianceMatrix,2),covarianceMatrixRank));end
  precalcmatrix = pinv(d.scm);
  % get the diagonal of the inverse of the design covariance matrix (used for estimating standard errors)
  diagOfInverseCovariance = diag(pinv(d.scm'*d.scm));
end

% check roi
slices = 1:d.dim(3);slicen = length(slices);
xvals = 1:d.dim(1);xvaln = length(xvals);
yvals = 1:d.dim(2);yvaln = length(yvals);
  
% preallocate memory
d.ehdr = zeros(d.dim(1),d.dim(2),d.dim(3),d.nhdr,d.hdrlen);
d.ehdrste = zeros(d.dim(1),d.dim(2),d.dim(3),d.nhdr,d.hdrlen);
d.r2 = zeros(d.dim(1),d.dim(2),d.dim(3));

% turn off warnings to avoid divide by zero warning
warning('off','MATLAB:divideByZero');

% display string
if verbose,disppercent(-inf,'(getr2) Calculating r2');end
(getr2) Calculating r2 00% (00:00:00)% cycle through images calculating the estimated hdr and r^2s of the 
% estimate.
%
% this following section has been optimized to run faster by
% eliminating one of the loops. Various different methods were
% tested eliminating all the loops and doing one big calculation
% which thrashed memory too much, or eliminating different
% dimensions and it was found that eliminating the first dimension
% was by far the faster by a factor of about 2-3. 
onesmatrix = ones(length(d.volumes),1);
for j = yvals
  for k = slices
    % get the time series we are working on
    % this includes all the rows of one column from one slice
    % and all data points for each of these
    % thus the time series is a nxm matrix where each of the m columns
    % contains the n time points recording for that voxel
    timeseries = squeeze(d.data(:,j,k,d.volumes))';
    % subtract off column means    
    colmeans = mean(timeseries,1);
    timeseries = timeseries - onesmatrix*colmeans;
    % convert to percent signal change
    timeseries = 100*timeseries./(onesmatrix*colmeans);
    % get hdr for the each voxel    
    ehdr{j,k} = precalcmatrix*timeseries;
    % calculate error bars, first get sum-of-squares of residual
    % (in percent signal change)
    sumOfSquaresResidual = sum((timeseries-d.scm*ehdr{j,k}).^2);
    % now calculate the sum-of-squares of that error
    % and divide by the degrees of freedom (n-k where n
    % is the number of timepoints in the scan and k is 
    % the number of timepoints in all the estimated hdr)
    S2 = sumOfSquaresResidual/(length(d.volumes)-size(d.scm,2));
    % now distribute that error to each one of the points
    % in the hemodynamic response according to the inverse
    % of the covariance of the stimulus convolution matrix.
    ehdrste{j,k} = sqrt(diagOfInverseCovariance*S2);
    % calculate variance accounted for by the estimated hdr
    r2{j,k} = (1-sumOfSquaresResidual./sum(timeseries.^2));
  end
  if verbose,disppercent(max((j-min(yvals))/yvaln,0.1));end
end
{Error using *
Inner matrix dimensions must agree.
} 
dbstack
> In getr2 at 16
  In getr2timecourse at 61
  In slfMRIerAnal at 130
dbquit
v = getMLRView;
(getView) Multiple figures open, returning last one
myROI          = loadROITSeries(v,o.myROIname);
(loadROITSeries) Loading tSeries for rMT from MotionComp: 1 00% (00:00:00)02% (00:01:10)05% (00:00:34)08% (00:00:22)10% (00:00:16)13% (00:00:12)16% (00:00:10)18% (00:00:08)21% (00:00:07)24% (00:00:06)27% (00:00:05)29% (00:00:04)32% (00:00:04)35% (00:00:03)37% (00:00:03)40% (00:00:02)43% (00:00:02)45% (00:00:02)48% (00:00:02)51% (00:00:01)54% (00:00:01)56% (00:00:01)59% (00:00:01)62% (00:00:01)64% (00:00:01)67% (00:00:00)70% (00:00:00)72% (00:00:00)75% (00:00:00)78% (00:00:00)81% (00:00:00)83% (00:00:00)86% (00:00:00)89% (00:00:00)91% (00:00:00)94% (00:00:00)97% (00:00:00)99% (00:00:00)took 1 secs 964 ms
scanDims       = viewGet(v,'scanDims');         
myROI.linearScanCoords = sub2ind(scanDims,myROI.scanCoords(1,:),myROI.scanCoords(2,:),myROI.scanCoords(3,:)); %ROI coord converted to linear
%r2             = viewGet(v,'overlayData',o.myGroupScanNum);    %r2 map that will permit to choose highest r2 voxels
r2             = viewGet(v,'overlayData',1);    %r2 map that will permit to choose highest r2 voxels
myROI.r2       = r2(myROI.linearScanCoords);                   %pick ROI's r2s
tSeries        = mean(myROI.tSeries(myROI.r2>o.myr2Thresh,:)); %average TSeries for high r2 vox
numVoxelsTotal = sum(myROI.r2>0); % # voxels with r2 greater than the threshold
numVoxels      = sum(myROI.r2 > o.myr2Thresh);
stimvol        = getStimvol(v,o.myVar,'taskNum',o.taskNum,'phaseNum',o.phaseNum,'segmentNum',o.segmentNum); %choose the # of HRF to deconvolve (i.e., # of stimuli) from the average TSeries.
(getStimvolFromVarname) taskNum=[2], phaseNum=[1], segmentNum=[2]
(getStimvolFromVarname) _all_: 15 trials
nhdr           = length(stimvol);
hdrlen         = 5; %hdr length'
size(scm)

ans =

    56    50

scm            = makescm(v,hdrlen,1,stimvol);
size(scm)

ans =

    56     5

v = getMLRView;
(getView) Multiple figures open, returning last one
myROI          = loadROITSeries(v,o.myROIname);
(loadROITSeries) Loading tSeries for rMT from MotionComp: 1 00% (00:00:00)02% (00:01:11)05% (00:00:34)08% (00:00:22)10% (00:00:16)13% (00:00:12)16% (00:00:10)18% (00:00:08)21% (00:00:07)24% (00:00:06)27% (00:00:05)29% (00:00:04)32% (00:00:04)35% (00:00:03)37% (00:00:03)40% (00:00:02)43% (00:00:02)45% (00:00:02)48% (00:00:02)51% (00:00:01)54% (00:00:01)56% (00:00:01)59% (00:00:01)62% (00:00:01)64% (00:00:01)67% (00:00:00)70% (00:00:00)72% (00:00:00)75% (00:00:00)78% (00:00:00)81% (00:00:00)83% (00:00:00)86% (00:00:00)89% (00:00:00)91% (00:00:00)94% (00:00:00)97% (00:00:00)99% (00:00:00)took 1 secs 999 ms
scanDims       = viewGet(v,'scanDims');         
myROI.linearScanCoords = sub2ind(scanDims,myROI.scanCoords(1,:),myROI.scanCoords(2,:),myROI.scanCoords(3,:)); %ROI coord converted to linear
%r2             = viewGet(v,'overlayData',o.myGroupScanNum);    %r2 map that will permit to choose highest r2 voxels
r2             = viewGet(v,'overlayData',1);    %r2 map that will permit to choose highest r2 voxels
myROI.r2       = r2(myROI.linearScanCoords);                   %pick ROI's r2s
tSeries        = mean(myROI.tSeries(myROI.r2>o.myr2Thresh,:)); %average TSeries for high r2 vox
numVoxelsTotal = sum(myROI.r2>0); % # voxels with r2 greater than the threshold
numVoxels      = sum(myROI.r2 > o.myr2Thresh);
stimvol        = getStimvol(v,o.myVar,'taskNum',o.taskNum,'phaseNum',o.phaseNum,'segmentNum',o.segmentNum); %choose the # of HRF to deconvolve (i.e., # of stimuli) from the average TSeries.
(getStimvolFromVarname) taskNum=[2], phaseNum=[1], segmentNum=[2]
(getStimvolFromVarname) _all_: 15 trials
nhdr           = length(stimvol);
hdrlen         = 25; %hdr length

%make a stimulus convolution matrix (scm, Ninstances by Nhdr's time. 
%scm = 1 at the times when we estimate hdr values).
scm            = makescm(v,hdrlen,1,stimvol);
size(scm)

ans =

    56    25

pwd

ans =

/Users/steeve/data/sltaskdotdirfmri05/s02520150814


 .m file has been backed up... 
