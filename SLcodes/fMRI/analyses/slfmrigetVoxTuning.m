
%slfmrigetVoxTuning.m
%
%
% author: steeve laquitaine
%  date : 160114
% status: completed and tested
%purpose: get voxel tunings parameters and permuted voxel responses 
%         distribution of tuning parameters 
%         Plot voxel tuning fit over variable 0 (e.g., directions) sorted 
%         by variable 1 (e.g., coherence or switching)
%
%Description: voxel responses are normalized to the mean response ((resp/mean)*100)
%
%  usage:
%
%      st = slfmrigetVoxTuning(1,'myRandomDir','mySwitch',15,d,'fminsearch')
%      st = slfmrigetVoxTuning(1,'myRandomDir','mySwitch=1',15,d,'cmaes')
%       
%
%input:
%     voxnum : voxel you want to plot (column of d.instances)
%       var0 : tuning x space (e.g., direction, orientation or location)
%       var1 : sort the tunings by other variable "var1" (e.g., coherence, switching)
%       var2 : another variable to select the data (e.g., 'myRandomCoh=0.06')
%          d : contains data in "d.instances" (n repeats x m voxels matrix)
%              variable 0 (e.g.,d.myRandomDir (n repeats x 1 vector)
%              variable 1 (e.g.,d.myRandomCoh (n repeats x 1 vector)
%              d can be generated by "slfmriGetInstancedb.m"
%
%    'nofit' : ("fminsearch", "gridsearchMean", or "cmaes"):
%
%               "gridsearchMean": Use it even if slow. it is very resistant 
%               to local minima. It set von mises initial mean
%               parameters with a grid search 1:1:360, the amplitude to the
%               mean amplitude over directions and k at 4. But slow (10 min/
%               500 voxels with parallel computing). Qualitatively good fit.
%
%               "fminsearch" is very fast 10 sec/500 voxels. But very
%               sensitive to local minima. For example it produces aberrant
%               high frequencies of voxel selectivities at 350 deg for simulation
%               of random values dataset. Qualitatively good fit.
%               
%
%varargin:
%       
%     'color': colors of plot
%              e.g., 'colors',[0 0 1]
%
%output :
%
%         conditions: n examples x m variables matrix of conditions
%     conditionsSubs: # of unique conditions
%       numCondition: # of unique conditions
%              count: 
%               mean: 
%                sem: 
%          fitvmMean: 
%             fitvmK: 
%             fitvmA: the amplitude scaling parameter
%         st.peakAmp: A*exp(k)/(2*pi.*besseli(0,k)); (The peak amplitude)
%      fitvmEquation: 'A*exp(k.*cos(x-u)-k)./(2*pi.*besseli(0,k,1))'
%          st.minsqe: best sum of squared error between model predictions and data
%        st.rsquared: percent explained variance in the data by the model
%
%
%
function st = slfmrigetVoxTuning(voxnum,var0,var1,var2,d,fitAlgo,varargin)

o = getAnalysisParams(varargin{:});

%case tuning is sorted by var1 values
%====================================
if ~any(var1=='=')
    
    %Bold response (instances by voxels)
    y = d.instances;
    
    %tuning x space
    x0 = d.(var0);

    %other variable to sort tuning
    x1 = d.(var1);
    
    %other variable to sort tuning
    var2nm = var2(1:find(var2=='=')-1);
    var2val = str2double(var2(find(var2=='=')+1:end));       
    x2 = d.(var2nm);
    
    %scale data to % signal change to the mean
    percSignal = d.instances(:,voxnum)/mean(d.instances(:,voxnum),1)*100;
    
    %Bold response (instances by voxels) for variable 1 value
    y = percSignal;
    
    %get stats (instance mean and sem by condition)
    st = SLmakeStat(y,x0,x1,x2);
    
    %unique variable values
    x1u = unique(x1);
    
    %plot mean and sem each condition
    set(gcf,'color','w')
    mycolx1 = linspecer(length(x1u));
    
    %tuning by var1 and var2 condition (colors)
    h = nan(1,length(x1u));
    lg = num2cell(h);
    for ix1 = 1 : length(x1u)
        var1Val = x1u(ix1);
        posVars = st.conditions(:,2) == var1Val & st.conditions(:,3) == var2val;
        var0Val = st.conditions(posVars,1);
        hold all
        %when condition exists
        if any(posVars)
            myerrorbar(var0Val,st.mean(posVars),'yError',st.sem(posVars),...
                'Symbol=o',['Color=[' num2str(mycolx1(ix1,:)) ']']);
            %get legend
            h(ix1) = plot(var0Val,st.mean(posVars),'color',mycolx1(ix1,:));
            lg{ix1} = num2str(x1u(ix1));
        end
    end
    xlabel(var0)
    ylabel('Response')
    legend(h,lg)%x1u)
end

%case tuning is for a specific value of var1 (e.g., var1=1)
if any(var1=='=')
    fprintf('%s \n','(slfmrigetVoxTuning) Getting tuning for a specific condition (var1).')
    
    %other variable to get tuning for
    %variable 1 name
    var1nm = var1(1:find(var1=='=')-1);        
    x1all = d.(var1nm);
    
    %var1 values (e.g.,'mySwitch=1') to get tuning for
    var1val = str2double(var1(find(var1=='=')+1:end));
    
    %var2
    var2nm = var2(1:find(var2=='=')-1);
    x2all = d.(var2nm);
    var2val = str2double(var2(find(var2=='=')+1:end));   
    posv1val = find((x1all==var1val & x2all==var2val));
        
    %scale data to % signal change to the mean
    percSignal = d.instances(:,voxnum)/mean(d.instances(:,voxnum),1)*100;
    
    %Bold response (instances by voxels) for variable 1 value
    y = percSignal(posv1val);
    
    %variable 0 (e.g., motion directions) for variable 1 value
    x0 = d.(var0)(posv1val);    
    
    %x1 values (same)
    x1 = x1all(posv1val);
    
    %get stats (instance mean and sem) for 
    %variable 1 value
    st = SLmakeStat(y,x0);
        
    %---------- plot mean and sem each condition data -----
    var0Val = st.conditions(:,1);    
    myerrorbar(var0Val,st.mean,'yError',st.sem,...
        'Symbol=o',['Color=' num2str(o.color)]);
    %get legend
    h(1) = plot(var0Val,st.mean,'.','linestyle','none','color',o.color);
    xlabel(var0)
    ylabel('Response')
    
    %--------- plot von mises fit ------------
    %to get the voxel tuning selectivity (variable 0 that elicits max 
    %response)
    %least square regression 
    %note: fmincon performed poorly by fminsearch does a great job.
    %Combinatio of grid search over mean good resolution for mean 
    %(no local minima)
    %and nonlinear opt over other params for each mean
    %cons: grid search is time slow
    %----- when fminsearch fit -----        
        
    %when no fit
    if any(strcmp(fitAlgo,'nofit'))        

        %output voxel tuning params
        [A,pos] = max(st.mean);
        st.fitvmMode = var0Val(pos);
        st.fitvmMean = nan;
        st.fitvmK = nan;
        st.fitvmA = A;
        st.peakAmp = A;
        st.fitvmEquation = 'no fit';
        st.minsqe = nan;     
        st.rsquared = nan;        
    end
    
    %when we fit
    if ~any(strcmp(fitAlgo,'nofit'))                       
        if any(strcmp(fitAlgo,'fminsearch'))                                                
            [sig,nVecs,actualnVec,actualnVecStrng,meantunStrngBydir,tunStrngCIbyDir,vecdir,minsqe] = slfMRIcheckVMfitTuningSignif(y,x0,1000);
        end
        
        %case grid search & fminsearch
        if any(strcmp(fitAlgo,'gridsearchMean'))  
           [sig,nVecs,actualnVec,actualnVecStrng,meantunStrngBydir,tunStrngCIbyDir,vecdir,minsqe] = slfMRIcheckGridSearchfitTuningSignif(y,x0,1000);
        end
        
        %----- when cmaes fit -----
        if any(strcmp(fitAlgo,'cmaes'))
            options = cmaes;
            options.LBounds = 0;   %no < 0
            options.TolFun = 1e-1; %stop when obj(t2) - obj(t1) < 1e-4
            [p(1,:),sqe] = cmaes('getVMfitsqecmaes',...
                [180;5;600],sqrt(var([180;3;600])),options,var0Val,st.mean);
            u = p(1,1);
            k = p(1,2);
            A = p(1,3);
            %A = p(1,3)*(2*pi.*besseli(0,k,1));
            minsqe = sqe;                   
        end
        
        %calculate percent explained variance (R-squared)
        %by the model
        rsquared = SLmakeR2(st.mean,minsqe);
        
        %convert to radians
        %plot tuning fit
        x2rad = SLde2r(1:1:360,0);
        u2rad = SLde2r(actualnVec.datadegmean,0);
        st.tuningFit = actualnVec.A*exp(actualnVecStrng.*cos(x2rad-u2rad)-actualnVecStrng);
        %st.tuningFit = A*exp(k.*cos(x2rad-u2rad)-k)./(2*pi.*besseli(0,k,1));
        hold on;
        xtun = 1:1:360;
        h(2) = plot(1:1:360,st.tuningFit,'color',o.color);
        legend(h,'data','von Mises fit')
        
        %==============================================
        %Solve case when there is more than one maximum
        %==============================================
        %randomly pick an argmax among the possible argmax        
        %e.g., if the max is positioned at the 4,5,6th index. Randomly
        %choose pick one index each time.
        [~,pos] = max(st.tuningFit);
        mymax = max(st.tuningFit);
        argmaxes_pos = find(st.tuningFit==mymax);
        jit = randperm(length(argmaxes_pos));
        pos = argmaxes_pos(jit(1));
        
        %output voxel tuning best fit params
        st.fitvmMode = xtun(pos);
        
        st.fitvmMean = SLra2d(u2rad);
        %case no preference k = 0
        if actualnVecStrng==0
            st.fitvmMode = NaN;
            st.fitvmMean = NaN;
        end        
        st.fitvmK = actualnVecStrng;
        st.fitvmA = actualnVec;
        st.peakAmp = NaN;        
        st.fitvmEquation = 'A*exp(k.*cos(x-u)-k)';        
        st.minsqe = minsqe;     % best sum of squared error
        st.rsquared = rsquared; % percent explained variance
        st.signifTun = sig;
        
        %save for plot
        st.nVecs.deg.mean = nVecs.deg.mean;
        st.actualnVecStrng = actualnVecStrng;
        st.actualnVec = actualnVec;
        st.meantunStrngBydir = meantunStrngBydir;
        st.tunStrngCIbyDir = tunStrngCIbyDir;
        st.vecdir = vecdir;
    end
end

function o = getAnalysisParams(varargin)

%color
if any(strcmp(varargin,'color'))
    o.color = varargin{find(strcmp(varargin,'color'))+1};
else
    o.color = 'k';
end

